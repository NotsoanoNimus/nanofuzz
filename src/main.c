/*
 * main.c
 *
 * Main entry point of the compiled CLI application.
 *
 */

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdbool.h>
#include <signal.h>
#include <string.h>
#include <getopt.h>
#include <err.h>
#include <errno.h>
#include <ctype.h>
#include <time.h>

#include <linux/limits.h>

#include "api.h"



static void __print_usage_info() {
    printf(
        "Usage: nanofuzz {-i|-p pattern|-f pattern-file} [-l count] [-w] [-o output-file]\n"
        "\n"
        "Generates fuzzer data from a provided pattern or schema, input through one of\n"
        "  three different methods. For more information about writing patterns for this\n"
        "  tool, see the provided man-page.\n"
        "\n"
        "Options:\n"
        "    -h, --help         Display this help.\n"
        "    -i, --stdin        Read the pattern schema as a string from STDIN.\n"
        "    -p, --pattern      Read the pattern schema from the provided option parameter.\n"
        "    -f, --file         Read the pattern schema from a specified text file.\n"
        "    -l, --limit        Print only 'count' generated lines and stop.\n"
        "    -w, --whitespace   Interpret all input white-space characters (' ', TAB, LF, etc.)\n"
        "                         as part of the pattern sequence. When this option is NOT used,\n"
        "                         the character literals '\\s', '\\r', etc. must be used when\n"
        "                         whitespace should be output in the generated byte streams.\n"
        "                         For more information, consult the man-page or documentation.\n"
        "    -o, --output       Write the generated output to the file specified. This can be a\n"
        "                         single file (which captures only the first result if '--limit'\n"
        "                         is used) or a filename pattern with a wildcard '*' in it. This\n"
        "                         wildcard expands to the current iteration number, from 0 to\n"
        "                         the '--limit' value minus one, if specified.\n"
        "\n"
        "\n"
    );
    exit( 1 );
}



// Other function declarations.
static void register_signal_handlers();
static void handle_signal( int signal );
static char* read_data_from_file( FILE* fp_file, bool gets_size );
void write_to_out_file( char* p_output_file, nanofuzz_data_t* p_data,
    size_t gen_num, size_t pfx );
#ifdef DEBUG
static void debug__print_hex( const char* p_dump_tag, const char* p_content, size_t len ) {
    printf( "DEBUG: HEX of '%s':\n", p_dump_tag );
    for ( size_t c = 0; c < len; c++ ) {
        if ( c % 8 == 0 )  printf( "    " );
        if ( c % 16 == 0 )  printf( "\n" );
        printf( "%02X ", (unsigned char)*(p_content+c) );
    }
    printf( "\n\n" );
}
#else   /* DEBUG */
static void debug__print_hex( const char* p_dump_tag, const char* p_content, size_t len ) {  }
#endif   /* DEBUG */

// Define a flags register and some bit indices.
static uint32_t app_flags = 0x00000000;
#define FLAG_PATTERN_STDIN (1 << 0)
#define FLAG_PATTERN_STRING (1 << 1)
#define FLAG_PATTERN_FILE (1 << 2)
#define FLAG_NO_SCRUB_WHITESPACE (1 << 3)
#define FLAG_COUNT_SET (1 << 4)
#define FLAG_WRITE_TO_FILE (1 << 5)


// Main.
int main( int argc, char* const argv[] ) {
    // Initial application setup.
    register_signal_handlers();

    // Set up options.
    struct option cli_long_opts[] = {
        { "help",       no_argument,        NULL,  'h' },
        { "stdin",      no_argument,        NULL,  'i' },
        { "pattern",    required_argument,  NULL,  'p' },
        { "file",       required_argument,  NULL,  'f' },
        { "limit",      required_argument,  NULL,  'l' },
        { "whitespace", no_argument,        NULL,  'w' },
        { "output",     required_argument,  NULL,  'o' },
        { NULL,         0,                  NULL,   0  }
    };

    int cli_opt_idx = 0;
    int cli_opt;

    char* p_pattern_file_path = NULL;
    char* p_pattern_contents = NULL;

    char* p_output_file = NULL;

    size_t amount_to_generate = 1;

    for ( ; ; ) {
        cli_opt = getopt_long( argc, argv, "hip:f:l:wo:", cli_long_opts, &cli_opt_idx );
        if ( cli_opt == -1 )  break;
        switch ( cli_opt ) {
            case '?':
            case 'h':
            default :
                __print_usage_info();
                break;

            case 'i':
                if ( (app_flags & FLAG_PATTERN_FILE) || (app_flags & FLAG_PATTERN_STRING) )
                    errx( 1, "The '-i', '-p', or '-f' flags are mutually exclusive. Please use only ONE of them.\n" );

                app_flags |= FLAG_PATTERN_STDIN;
                break;

            case 'p':
                if ( (app_flags & FLAG_PATTERN_FILE) || (app_flags & FLAG_PATTERN_STDIN) )
                    errx( 1, "The '-i', '-p', or '-f' flags are mutually exclusive. Please use only ONE of them.\n" );
                else if ( (app_flags & FLAG_PATTERN_STRING) )
                    errx( 1, "The pattern string (-p) option can only be specified once.\n" );

                app_flags |= FLAG_PATTERN_STRING;

                // Initialize the pattern directly from the option argument.
                if ( strnlen( optarg, FUZZ_MAX_PATTERN_LENGTH ) >= FUZZ_MAX_PATTERN_LENGTH ) {
                    errx( 1, "The given pattern exceeds the maximum parseable pattern length of %lu bytes.\n",
                        (unsigned long)FUZZ_MAX_PATTERN_LENGTH );
                } else if ( strnlen( optarg, 1 ) ) {
                    p_pattern_contents = strndup( optarg, (FUZZ_MAX_PATTERN_LENGTH-1) );
                    p_pattern_contents[strlen(p_pattern_contents)] = '\0';
                } else {
                    errx( 1, "A valid pattern must be supplied with the '-p' flag.\n" );
                }

                break;

            case 'f':
                if ( (app_flags & FLAG_PATTERN_STDIN) || (app_flags & FLAG_PATTERN_STRING) )
                    errx( 1, "The '-i', '-p', or '-f' flags are mutually exclusive. Please use only ONE of them.\n" );
                else if ( (app_flags & FLAG_PATTERN_FILE) || p_pattern_file_path != NULL )
                    errx( 1, "The pattern file (-f) option can only be specified once.\n" );

                app_flags |= FLAG_PATTERN_FILE;

                // Copy the file path from the option argument into the file_path pointer, if not already set.
                if ( strnlen( optarg, (PATH_MAX-1) ) < 1 )
                    errx( 1, "The pattern file (-f) must be a path to a readable text file.\n" );

                p_pattern_file_path = strndup( optarg, (PATH_MAX-1) );
                if ( p_pattern_file_path == NULL )
                    errx( 1, "Failed to understand or copy the '-f' option argument string.\n" );

                break;

            case 'l':
                if ( (app_flags & FLAG_COUNT_SET) )
                    errx( 1, "The count of generated lines can only be specified once.\n" );

                app_flags |= FLAG_COUNT_SET;

                if ( strnlen( optarg, 3 ) == 2 && strncmp( optarg, "-1", 2 ) == 0 ) {
                    amount_to_generate = 0;   //infinite
                } else {
                    for ( const char* x = optarg; (*x); x++ )
                        if ( !isdigit( (int)(*x) ) )
                            errx( 1, "The '-l' option's value must be a positive, base-10 (decimal) integer.\n" );

                    errno = 0;
                    amount_to_generate = (size_t)strtoul( optarg, NULL, 10 );
                    if ( errno ) {
                        perror( "'-l' option" );
                        exit( 1 );
                    }
                }

                break;

            case 'w':
                app_flags |= FLAG_NO_SCRUB_WHITESPACE;
                break;

            case 'o':
                // -32 to account for size_t string expansion
                p_output_file = strndup( optarg, (PATH_MAX-33) );

                if ( NULL == p_output_file || strnlen( p_output_file, 2 ) < 2 ) {
                    errx( 1, "Misunderstood output filename for the '-o' option.\n" );
                }

                app_flags |= FLAG_WRITE_TO_FILE;
                break;
        }
    }


    // Now double-check options provided through the application's options as needed.
    if ( (app_flags & FLAG_PATTERN_FILE) ) {

        // Open the file and make sure the handle is OK.
        FILE* fp_pattern_file = fopen( p_pattern_file_path, "rb" );
        if ( !fp_pattern_file )  errx( 1, "Unable to open pattern file '%s'.\n", p_pattern_file_path );

        // Get the data from the pattern file.
        p_pattern_contents = read_data_from_file( fp_pattern_file, true );

        // Close the file handle and release pointers as appropriate.
        fclose( fp_pattern_file );
        if ( p_pattern_file_path != NULL )  free( p_pattern_file_path );

    } else if ( (app_flags & FLAG_PATTERN_STDIN) ) {

        // Read the contents of the pattern string from STDIN.
        // TODO: Is there a better way to read STDIN maybe?
        errno = 0;
        FILE* fp_stdin = freopen( NULL, "rb", stdin );
        if ( !fp_stdin ) {
            perror( "problem reading from STDIN fd" );
            exit( 1 );
        }

        // Attempt to read the data from STDIN.
        p_pattern_contents = read_data_from_file( fp_stdin, false );

        // Close the 'reopened' STDIN stream.
        fclose( fp_stdin );
    }


    // If FLAG_NO_SCRUB_WHITESPACE is NOT set, scrub out any whitespace characters from the input.
    //   This includes 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x20.
    if (  NULL != p_pattern_contents && !(app_flags & FLAG_NO_SCRUB_WHITESPACE)  ) {
        char* p_i = NULL;
        char* p_j = NULL;
        for ( p_i = p_pattern_contents; p_i && *(p_i); ) {
            switch ( (int)(*p_i) ) {
                case 0x09 :
                case 0x0A :
                case 0x0B :
                case 0x0C :
                case 0x0D :
                case 0x20 :
                    for ( p_j = p_i; p_j && *(p_j); p_j++ )
                        *p_j = *(p_j + 1);
                    break;
                default :
                    p_i++;
                    continue;
            }
        }
    }


    // Check that a pattern actually exists to parse.
    if ( NULL == p_pattern_contents || !strnlen( p_pattern_contents, 1 ) )
        errx( 1, "A pattern to parse was not found. Please check the provided options and try again.\n" );

    // Create a new error context to read problems from the pattern string, if any.
    fuzz_error_t* p_err_ctx = NULL;

    // Parse the input pattern and init a fuzzer context.
    nanofuzz_context_t* p_fuzz_ctx = Nanofuzz__new( p_pattern_contents, &p_err_ctx );
    if ( NULL == p_fuzz_ctx ) {
        Error__print( p_err_ctx, stderr );
        free( p_pattern_contents );
        exit( 1 );
    } else {
        // Explain the factory.
        Nanofuzz__PatternFactory__explain( stdout, p_fuzz_ctx );
    }

    // Generate data using the constructed context. If amount_to_generate is less than 1
    //   the program will loop. This is intentional.
    size_t i = 0, gen_num = 0, pfx = 0;
    while ( i < amount_to_generate || !amount_to_generate ) {

        nanofuzz_data_t* p_data = Nanofuzz__get_next( p_fuzz_ctx );

        if ( p_data ) {
            if ( (app_flags & FLAG_WRITE_TO_FILE) ) {
                write_to_out_file( p_output_file, p_data, gen_num, pfx );
            } else {
                printf(  "%s\n", (const char*)(p_data->output)  );
            }
        } else {
            printf( "Content generation failure.\n" );
            exit(1);
        }

        Nanofuzz__delete_data( p_data );
        if ( amount_to_generate )  i++;

        // I mean really, this shouldn't happen but.....
        gen_num++;
        if ( gen_num >= UINT64_MAX )  pfx++;

    }


    // Free resource allocations. All done.
    Nanofuzz__delete( p_fuzz_ctx );
    free( p_output_file );
    free( p_pattern_contents );
}



static void register_signal_handlers() {
    static struct sigaction sa;
    memset( &sa, 0, sizeof(struct sigaction) );
    sa.sa_handler = handle_signal;
    sigaction( SIGINT,  &sa, NULL );
    sigaction( SIGTERM, &sa, NULL );
    sigaction( SIGHUP,  &sa, NULL );
    return;
}


static void handle_signal( int signal ) {
    fprintf( stderr, "Received signal '%d'. Goodbye.\n", signal );
    exit( 0 );
}


static char* read_data_from_file( FILE* fp_file, bool gets_size ) {
        // Ensure the pattern file or STDIN is valid, and a string with 1 or more chars is read from it.
        static char buffer[32] = {0};
        size_t bytes = 0, read_count = 0, file_size = 0;
        char* p_pattern_data = NULL;

        // Get the file size.
        if ( gets_size ) {
            errno = 0;
            fseek( fp_file, 0L, SEEK_END );
            if ( errno ) {
                perror( "fseek end: unseekable file" );
                exit( 1 );
            }
            errno = 0;
            file_size = ftell( fp_file );
            fseek( fp_file, 0L, SEEK_SET );
            if ( errno ) {
                perror( "fseek set: unseekable file" );
                exit( 1 );
            }
        } else  file_size = (FUZZ_MAX_PATTERN_LENGTH-1);

        // Make sure it doesn't exceed the maximum parseable pattern length.
        if ( file_size >= FUZZ_MAX_PATTERN_LENGTH )
            errx( 1, "The given pattern exceeds the maximum parseable pattern size of %lu bytes.\n",
                (unsigned long)FUZZ_MAX_PATTERN_LENGTH );

        // Allocate the buffer in the heap to store the file's contents.
        char* p_read = (char*)calloc( (file_size+1), 1 );

        while ( (bytes = fread( buffer, sizeof(unsigned char), sizeof(buffer), fp_file )) ) {
            if ( (read_count+bytes) > file_size )
                errx( 1, "The pattern exceeded the expected file size of %lu bytes.\n", file_size );

            if ( strnlen( buffer, sizeof(buffer) ) )
                memcpy( (p_read+read_count), buffer, bytes );

            memset( buffer, 0, sizeof(buffer) );

            // Keep counting.
            read_count += bytes;
        }

        // Now assign the read contents to the pattern_contents location.
        p_pattern_data = strdup( p_read ); //, strnlen( p_read, FUZZ_MAX_PATTERN_LENGTH-1 )  );

        if ( p_read != NULL )  free( p_read );

        // One last check to make sure the pattern is filled.
        if ( !strnlen( p_pattern_data, 2 ) )
            errx( 1, "Unable to discern a pattern. Was one properly provided?\n" );

        return p_pattern_data;
}



void write_to_out_file(
    char* p_output_file,
    nanofuzz_data_t* p_data,
    size_t gen_num,
    size_t pfx
) {

    if ( NULL == p_data || 0 == p_data->length )  return;

    char* const x = (char*)calloc( PATH_MAX, sizeof(char) );   //intermediate
    char* const p_filename = (char*)calloc( PATH_MAX, sizeof(char) );
    FILE* fp_out = NULL;
    char* asterisk = NULL;

    // Copy in the path name. It's done this way so the 'x' buffer can be larger.
    memcpy( x, p_output_file, strlen(p_output_file) );

    // Find the position of the first asterisk and delete the rest thereafter.
    for ( char* y = x; *y; y++ ) {
        if ( '*' == *y ) {
            if ( !asterisk ) {
                asterisk = y;
            }
            for ( char* z = y; *z; z++ )
                *z = *(z+1);
            y--;
        }
    }

    // Copy up to the first wildcard, then the numbers, then the rest of the filename.
    if ( asterisk ) {
        if ( (asterisk-x) > 0 )
            memcpy( p_filename, x, (asterisk - x) );

        sprintf( (p_filename+(asterisk-x)), "%05lu%09lu", pfx, gen_num );
        sprintf( (p_filename+strlen(p_filename)), "%s", asterisk );
    } else {
        memcpy( p_filename, x, strlen(x) );
    }

    // Open the handle to the output file.
    fp_out = fopen( p_filename, "wb" );
    if ( NULL == fp_out ) {
        fprintf( stderr, "Problem writing to output file at: '%s'\n", p_filename );
        free( (void*)p_filename );
        free( (void*)x );
        return;
    }

    // Attempt to write the output to the handle.
    size_t bytes_written = fwrite( p_data->output, sizeof(unsigned char),
        p_data->length, fp_out );

    if ( bytes_written != p_data->length )
        fprintf( stderr, "Problem writing all output to file at: '%s'\n", p_filename );

    fclose( fp_out );
    free( (void*)p_filename );
    free( (void*)x );

}
