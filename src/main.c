/*
 * main.c
 *
 * Main entry point of the compiled CLI application.
 *
 */

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdbool.h>
#include <signal.h>
#include <string.h>
#include <getopt.h>
#include <err.h>
#include <errno.h>
#include <ctype.h>
#include <time.h>
#include <unistd.h>
#include <pthread.h>

#include <linux/limits.h>

#include "api.h"

// Define constants as necessary.
#define FUZZ_MAX_THREADS 16



static void __print_usage_info() {
    printf(
        "Usage: nanofuzz {-i|-p pattern|-f pattern-file} [-l count] [-w] [-o output-file]\n"
        "\n"
        "Generates fuzzer data from a provided pattern or schema, input through one of\n"
        "  three different methods. For more information about writing patterns for this\n"
        "  tool, see the provided man-page.\n"
        "\n"
        "Options:\n"
        "    -h, --help         Display this help.\n"
        "    -i, --stdin        Read the pattern schema as a string from STDIN.\n"
        "    -p, --pattern      Read the pattern schema from the provided option parameter.\n"
        "    -f, --file         Read the pattern schema from a specified text file.\n"
        "    -t, --threads      Number of threads to spawn (between 1 and %d) for generation.\n"
        "                         Be careful setting this option above available resources.\n"
        "    -l, --limit        Print only 'count' generated lines and stop.\n"
        "    -w, --whitespace   Interpret all input white-space characters (' ', TAB, LF, etc.)\n"
        "                         as part of the pattern sequence. When this option is NOT used,\n"
        "                         the character literals '\\s', '\\r', etc. must be used when\n"
        "                         whitespace should be output in the generated byte streams.\n"
        "                         For more information, consult the man-page or documentation.\n"
        "    -o, --output       Write the generated output to the file specified. This can be a\n"
        "                         single file (which captures only the first result if '--limit'\n"
        "                         is used) or a filename pattern with a wildcard '*' in it. This\n"
        "                         wildcard expands to the current iteration number, from 0 to\n"
        "                         the '--limit' value minus one, if specified.\n"
        "\n"
        "\n", FUZZ_MAX_THREADS
    );
    exit( 1 );
}



// Other function declarations.
void* thread_do_work( void* p_work );
void thread_update_amount( size_t generated );
static void register_signal_handlers();
static void handle_signal( int signal );
static char* read_data_from_file( FILE* fp_file, bool gets_size );
void write_to_out_file( nanofuzz_data_t* p_data, size_t gen_num, size_t pfx );



// Internal structure for providing spawned threads with information and 'work to do'.
typedef struct _thread_work_t {
    nanofuzz_context_t* p_fuzz_ctx;   //reuseable generator context (pattern never changes)
    size_t jobs;   //amount to generate
    size_t counter;   //number to start at (when outputting to files)
    size_t pfx;   //file prefix in case of overflows in 'counter'
} thread_work_t;

// Thread context wrapper struct.
typedef struct _thread_ctx_t {
    pthread_t thread;   //the current thread being checked/assigned
    thread_work_t* p_work;   //its workload
} thread_ctx_t;


// Define global variables as needed.
static size_t amount_generated = 0;   // Amount done so far
static size_t amount_to_generate = 1;   // Amount of cycles
static pthread_mutex_t _amount_mutex   // mutex for ^ counter
    = PTHREAD_MUTEX_INITIALIZER;
static thread_ctx_t* threads[FUZZ_MAX_THREADS];   // App-global thread context ptrs
static char* p_output_file = NULL;   //pointer to the template name of out files


// Define a flags register and some bit indices.
static uint32_t app_flags = 0x00000000;
#define FLAG_PATTERN_STDIN (1 << 0)
#define FLAG_PATTERN_STRING (1 << 1)
#define FLAG_PATTERN_FILE (1 << 2)
#define FLAG_NO_SCRUB_WHITESPACE (1 << 3)
#define FLAG_COUNT_SET (1 << 4)
#define FLAG_WRITE_TO_FILE (1 << 5)
#define FLAG_OUTFILE_DYNAMIC (1 << 6)
#define FLAG_THREAD_COUNT (1 << 7)



// Main.
int main( int argc, char* const argv[] ) {
    // Initial application setup.
    register_signal_handlers();

    // Set up options.
    struct option cli_long_opts[] = {
        { "help",       no_argument,        NULL,  'h' },
        { "stdin",      no_argument,        NULL,  'i' },
        { "pattern",    required_argument,  NULL,  'p' },
        { "file",       required_argument,  NULL,  'f' },
        { "threads",    required_argument,  NULL,  't' },
        { "limit",      required_argument,  NULL,  'l' },
        { "whitespace", no_argument,        NULL,  'w' },
        { "output",     required_argument,  NULL,  'o' },
        { NULL,         0,                  NULL,   0  }
    };

    int cli_opt_idx = 0;
    int cli_opt;

    size_t worker_threads = 0;

    char* p_pattern_file_path = NULL;
    char* p_pattern_contents = NULL;

    for ( ; ; ) {
        cli_opt = getopt_long( argc, argv, "hip:f:t:l:wo:", cli_long_opts, &cli_opt_idx );
        if ( cli_opt == -1 )  break;
        switch ( cli_opt ) {
            case '?':
            case 'h':
            default :
                __print_usage_info();
                break;

            case 'i':
                if ( (app_flags & FLAG_PATTERN_FILE) || (app_flags & FLAG_PATTERN_STRING) )
                    errx( 1, "The '-i', '-p', or '-f' flags are mutually exclusive. Please use only ONE of them.\n" );

                app_flags |= FLAG_PATTERN_STDIN;
                break;

            case 'p':
                if ( (app_flags & FLAG_PATTERN_FILE) || (app_flags & FLAG_PATTERN_STDIN) )
                    errx( 1, "The '-i', '-p', or '-f' flags are mutually exclusive. Please use only ONE of them.\n" );
                else if ( (app_flags & FLAG_PATTERN_STRING) )
                    errx( 1, "The pattern string (-p) option can only be specified once.\n" );

                app_flags |= FLAG_PATTERN_STRING;

                // Initialize the pattern directly from the option argument.
                if ( strnlen( optarg, FUZZ_MAX_PATTERN_LENGTH ) >= FUZZ_MAX_PATTERN_LENGTH ) {
                    errx( 1, "The given pattern exceeds the maximum parseable pattern length of %lu bytes.\n",
                        (unsigned long)FUZZ_MAX_PATTERN_LENGTH );
                } else if ( strnlen( optarg, 1 ) ) {
                    p_pattern_contents = strndup( optarg, (FUZZ_MAX_PATTERN_LENGTH-1) );
                    p_pattern_contents[strlen(p_pattern_contents)] = '\0';
                } else {
                    errx( 1, "A valid pattern must be supplied with the '-p' flag.\n" );
                }

                break;

            case 'f':
                if ( (app_flags & FLAG_PATTERN_STDIN) || (app_flags & FLAG_PATTERN_STRING) )
                    errx( 1, "The '-i', '-p', or '-f' flags are mutually exclusive. Please use only ONE of them.\n" );
                else if ( (app_flags & FLAG_PATTERN_FILE) || p_pattern_file_path != NULL )
                    errx( 1, "The pattern file (-f) option can only be specified once.\n" );

                app_flags |= FLAG_PATTERN_FILE;

                // Copy the file path from the option argument into the file_path pointer, if not already set.
                if ( strnlen( optarg, (PATH_MAX-1) ) < 1 )
                    errx( 1, "The pattern file (-f) must be a path to a readable text file.\n" );

                p_pattern_file_path = strndup( optarg, (PATH_MAX-1) );
                if ( p_pattern_file_path == NULL )
                    errx( 1, "Failed to understand or copy the '-f' option argument string.\n" );

                break;

            case 't':
                if ( (app_flags & FLAG_THREAD_COUNT) )
                    errx( 1, "The count of worker threads can only be specified once.\n" );

                app_flags |= FLAG_THREAD_COUNT;

                for ( const char* x = optarg; (*x); x++ )
                    if ( !isdigit( (int)(*x) ) )
                        errx( 1, "The '-t' option's value must be a"
                            " positive integer between 1 and %d.\n", FUZZ_MAX_THREADS );

                errno = 0;
                worker_threads = (size_t)strtoul( optarg, NULL, 10 );
                if ( errno ) {
                    perror( "'-t' option" );
                    exit( 1 );
                } else if ( worker_threads > FUZZ_MAX_THREADS || worker_threads < 1 ) {
                        errx( 1, "The '-t' option's value must be a"
                            " positive integer between 1 and %d.\n", FUZZ_MAX_THREADS );
                }

                break;

            case 'l':
                if ( (app_flags & FLAG_COUNT_SET) )
                    errx( 1, "The count of generated lines can only be specified once.\n" );

                app_flags |= FLAG_COUNT_SET;

                if ( strnlen( optarg, 3 ) == 2 && strncmp( optarg, "-1", 2 ) == 0 ) {
                    amount_to_generate = 0;   //infinite
                } else {
                    for ( const char* x = optarg; (*x); x++ )
                        if ( !isdigit( (int)(*x) ) )
                            errx( 1, "The '-l' option's value must be a positive, base-10 (decimal) integer.\n" );

                    errno = 0;
                    amount_to_generate = (size_t)strtoul( optarg, NULL, 10 );
                    if ( errno ) {
                        perror( "'-l' option" );
                        exit( 1 );
                    } else if ( amount_to_generate <= 0 ) {
                        errx( 1, "The '-l' option's value must be a positive, base-10 (decimal) integer.\n" );
                    }
                }

                break;

            case 'w':
                app_flags |= FLAG_NO_SCRUB_WHITESPACE;
                break;

            case 'o':
                if ( (app_flags & FLAG_WRITE_TO_FILE) )
                    errx( 1, "The output file format '-o' can only be specified once.\n" );

                // -32 to account for size_t string expansion
                p_output_file = strndup( optarg, (PATH_MAX-33) );

                if ( NULL == p_output_file || strnlen( p_output_file, 2 ) < 2 )
                    errx( 1, "Misunderstood output filename for the '-o' option.\n" );

                app_flags |= FLAG_WRITE_TO_FILE;

                // Need to verify that if threading is used, filenames have a wildcard.
                for ( const char* x = p_output_file; (*x); x++ ) {
                    if ( '*' == *x ) {
                        app_flags |= FLAG_OUTFILE_DYNAMIC;
                        break;
                    }
                }

                break;
        }
    }


    // Make sure that if threading is enabled, a wildcard was used in the output filename.
    if ( (app_flags & FLAG_WRITE_TO_FILE) && (app_flags & FLAG_THREAD_COUNT) )
        if ( !(app_flags & FLAG_OUTFILE_DYNAMIC) )
            errx( 1, "Threading with file output REQUIRES the use of a"
                " wildcard '*' character in the outfile.\n" );


    // Now double-check options provided through the application's options as needed.
    if ( (app_flags & FLAG_PATTERN_FILE) ) {

        // Open the file and make sure the handle is OK.
        FILE* fp_pattern_file = fopen( p_pattern_file_path, "rb" );
        if ( !fp_pattern_file )  errx( 1, "Unable to open pattern file '%s'.\n", p_pattern_file_path );

        // Get the data from the pattern file.
        p_pattern_contents = read_data_from_file( fp_pattern_file, true );

        // Close the file handle and release pointers as appropriate.
        fclose( fp_pattern_file );
        if ( p_pattern_file_path != NULL )  free( p_pattern_file_path );

    } else if ( (app_flags & FLAG_PATTERN_STDIN) ) {

        // Read the contents of the pattern string from STDIN.
        // TODO: Is there a better way to read STDIN maybe?
        errno = 0;
        FILE* fp_stdin = freopen( NULL, "rb", stdin );
        if ( !fp_stdin ) {
            perror( "problem reading from STDIN fd" );
            exit( 1 );
        }

        // Attempt to read the data from STDIN.
        p_pattern_contents = read_data_from_file( fp_stdin, false );

        // Close the 'reopened' STDIN stream.
        fclose( fp_stdin );
    }


    // If FLAG_NO_SCRUB_WHITESPACE is NOT set, scrub out any whitespace characters from the input.
    //   This includes 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x20.
    if (  NULL != p_pattern_contents && !(app_flags & FLAG_NO_SCRUB_WHITESPACE)  ) {
        char* p_i = NULL;
        char* p_j = NULL;
        for ( p_i = p_pattern_contents; p_i && *(p_i); ) {
            switch ( (int)(*p_i) ) {
                case 0x09 :
                case 0x0A :
                case 0x0B :
                case 0x0C :
                case 0x0D :
                case 0x20 :
                    for ( p_j = p_i; p_j && *(p_j); p_j++ )
                        *p_j = *(p_j + 1);
                    break;
                default :
                    p_i++;
                    continue;
            }
        }
    }


    // Check that a pattern actually exists to parse.
    if ( NULL == p_pattern_contents || !strnlen( p_pattern_contents, 1 ) )
        errx( 1, "A pattern to parse was not found. Please check the provided options and try again.\n" );

    // Create a new error context to read problems from the pattern string, if any.
    fuzz_error_t* p_err_ctx = NULL;

    // Parse the input pattern and init a fuzzer context.
    nanofuzz_context_t* p_fuzz_ctx = Nanofuzz__new( p_pattern_contents, &p_err_ctx );
    if ( NULL == p_fuzz_ctx ) {
        // If the program can't understand the pattern, die.
        Nanofuzz__delete( p_fuzz_ctx );
        Error__print( p_err_ctx, stderr );
        free( p_pattern_contents );
        exit( 1 );
    } else {
        // Explain the factory.
        Nanofuzz__PatternFactory__explain( stdout, p_fuzz_ctx );
    }

    // Generate data using the constructed context. If amount_to_generate is less than 1
    //   the program will loop. This is intentional.
    if ( worker_threads <= 1 ) {
        size_t i = 0, gen_num = 0, pfx = 0;
        while ( i < amount_to_generate || !amount_to_generate ) {

            nanofuzz_data_t* p_data = Nanofuzz__get_next( p_fuzz_ctx );

            if ( NULL != p_data ) {
                if ( (app_flags & FLAG_WRITE_TO_FILE) ) {
                    write_to_out_file( p_data, gen_num, pfx );
                } else {
                    printf(  "%s\n", (const char*)(p_data->output)  );
                }
            } else {
                printf( "Content generation failure.\n" );
                exit(1);
            }

            Nanofuzz__delete_data( p_data );
            if ( amount_to_generate )  i++;

            // I mean really, this shouldn't happen but.....
            gen_num++;
            if ( gen_num >= UINT64_MAX )  pfx++;
        }
    } else {
        // Init the list of thread context pointers to 0.
        memset( &threads, 0, (sizeof(thread_ctx_t*)*FUZZ_MAX_THREADS) );

        thread_ctx_t** pp_tctx = &(threads[0]);
        fuzz_error_t* p_dummy_ctx = NULL;

        for ( size_t i = 0; i < worker_threads; i++ ) {
            *(pp_tctx+i) = (thread_ctx_t*)calloc( 1, sizeof(thread_ctx_t) );

            // Assign the work to-do based on the amount to generate and the amount of threads.
            thread_work_t* p_wrk = (thread_work_t*)calloc( 1, sizeof(thread_work_t) );
            p_wrk->pfx = 0;   //always initially 0
            p_wrk->jobs = ( amount_to_generate ? (amount_to_generate / worker_threads) : UINT64_MAX );
            p_wrk->counter = (i * p_wrk->jobs);   //at its place in line
            // ^ ex: 100,000 jobs; 4 threads ==> 0-24,999; 25,000-49,999; etc.
            if ( amount_to_generate && (i == (worker_threads-1)) ) {   //on the last thread in line...
                // get the final difference between what was already alloc'd and what's left to do
                p_wrk->jobs = amount_to_generate - (p_wrk->jobs * (worker_threads-1));
            }
            //printf( "WORK: |%lu jobs|  |%lu counter|\n", p_wrk->jobs, p_wrk->counter );

            (*(pp_tctx+i))->p_work = p_wrk;

            // Create the fuzzer contexts, one per thread.
            //   No need for error context informstion since the above context creation worked.
            (*(pp_tctx+i))->p_work->p_fuzz_ctx = Nanofuzz__new( p_pattern_contents, &p_dummy_ctx );
            if ( NULL == (*(pp_tctx+i))->p_work->p_fuzz_ctx )
                errx( 1, "Failed to create fuzzing context in worker thread #%lu. Aborting.\n", i );

            Error__delete( p_dummy_ctx );

            // Create a thread attribute block for detached state.
            pthread_attr_t tattr;
            pthread_attr_init( &tattr );
            pthread_attr_setdetachstate( &tattr, 1 );

            // Create the pthread and save the pointer.
            memset( &((*(pp_tctx+i))->thread), 0, sizeof(pthread_t) );

            int rc = pthread_create( &((*(pp_tctx+i))->thread), &tattr, thread_do_work, (*(pp_tctx+i))->p_work );
            if ( rc )
                errx( 1, "Failed to create worker thread #%lu. Aborting.\n", i );

            pthread_attr_destroy( &tattr );
        }

        // Keep the main thread alive while the threads do their work.
        while ( amount_generated < amount_to_generate || !amount_to_generate ) {
            usleep( 10000 );
        }

        // If the program gets here, clean up.
        for ( size_t i = 0; i < worker_threads; i++ ) {
            if ( NULL != *(pp_tctx+i) ) {
                if ( NULL != (*(pp_tctx+i))->p_work )
                    free( (*(pp_tctx+i))->p_work );
                free( (void*)(*(pp_tctx+i)) );
            }
        }
    }


    // Free resource allocations. All done.
    Nanofuzz__delete( p_fuzz_ctx );
    free( p_output_file );
    free( p_pattern_contents );
}



// Threading function to generate fuzzer data from each thread, until there
//   is no more work to do in the current context.
void* thread_do_work( void* p_work ) {
    thread_work_t* p_do = (thread_work_t*)p_work;

    // If the jobs count is UINT64_MAX, this will go on forever.
    size_t howmany = p_do->jobs;
    while ( howmany ) {
        nanofuzz_data_t* p_data = Nanofuzz__get_next( p_do->p_fuzz_ctx );
        if ( NULL != p_data ) {
            if ( (app_flags & FLAG_WRITE_TO_FILE) ) {
                 write_to_out_file( p_data,
                    (p_do->counter + (p_do->jobs - howmany)), p_do->pfx );
            } else {
                //printf(  "%s\n", (const char*)(p_data->output)  );
            }
        }

        Nanofuzz__delete_data( p_data );
        if ( howmany < UINT64_MAX )  howmany--;
    }

    thread_update_amount( p_do->jobs );

    return NULL;
}


// If the program is not running until infinity, increment the amount-generated counter.
void thread_update_amount( size_t generated ) {
    pthread_mutex_lock( &_amount_mutex );
    amount_generated += generated;
    pthread_mutex_unlock( &_amount_mutex );
}



static void register_signal_handlers() {
    static struct sigaction sa;
    memset( &sa, 0, sizeof(struct sigaction) );
    sa.sa_handler = handle_signal;
    sigaction( SIGINT,  &sa, NULL );
    sigaction( SIGTERM, &sa, NULL );
    sigaction( SIGHUP,  &sa, NULL );
    return;
}


static void handle_signal( int signal ) {
    fprintf( stderr, "Received signal '%d'. Goodbye.\n", signal );
    exit( 0 );
}


static char* read_data_from_file( FILE* fp_file, bool gets_size ) {
        // Ensure the pattern file or STDIN is valid, and a string with 1 or more chars is read from it.
        static char buffer[32] = {0};
        size_t bytes = 0, read_count = 0, file_size = 0;
        char* p_pattern_data = NULL;

        // Get the file size.
        if ( gets_size ) {
            errno = 0;
            fseek( fp_file, 0L, SEEK_END );
            if ( errno ) {
                perror( "fseek end: unseekable file" );
                exit( 1 );
            }
            errno = 0;
            file_size = ftell( fp_file );
            fseek( fp_file, 0L, SEEK_SET );
            if ( errno ) {
                perror( "fseek set: unseekable file" );
                exit( 1 );
            }
        } else  file_size = (FUZZ_MAX_PATTERN_LENGTH-1);

        // Make sure it doesn't exceed the maximum parseable pattern length.
        if ( file_size >= FUZZ_MAX_PATTERN_LENGTH )
            errx( 1, "The given pattern exceeds the maximum parseable pattern size of %lu bytes.\n",
                (unsigned long)FUZZ_MAX_PATTERN_LENGTH );

        // Allocate the buffer in the heap to store the file's contents.
        char* p_read = (char*)calloc( (file_size+1), 1 );

        while ( (bytes = fread( buffer, sizeof(unsigned char), sizeof(buffer), fp_file )) ) {
            if ( (read_count+bytes) > file_size )
                errx( 1, "The pattern exceeded the expected file size of %lu bytes.\n", file_size );

            if ( strnlen( buffer, sizeof(buffer) ) )
                memcpy( (p_read+read_count), buffer, bytes );

            memset( buffer, 0, sizeof(buffer) );

            // Keep counting.
            read_count += bytes;
        }

        // Now assign the read contents to the pattern_contents location.
        p_pattern_data = strdup( p_read ); //, strnlen( p_read, FUZZ_MAX_PATTERN_LENGTH-1 )  );

        if ( p_read != NULL )  free( p_read );

        // One last check to make sure the pattern is filled.
        if ( !strnlen( p_pattern_data, 2 ) )
            errx( 1, "Unable to discern a pattern. Was one properly provided?\n" );

        return p_pattern_data;
}



void write_to_out_file( nanofuzz_data_t* p_data, size_t gen_num, size_t pfx ) {

    if ( NULL == p_output_file || NULL == p_data || 0 == p_data->length )  return;

    char* const x = (char*)calloc( PATH_MAX, sizeof(char) );   //intermediate
    char* const p_filename = (char*)calloc( PATH_MAX, sizeof(char) );
    FILE* fp_out = NULL;
    char* asterisk = NULL;

    // Copy in the path name. It's done this way so the 'x' buffer can be larger.
    memcpy( x, p_output_file, strlen(p_output_file) );

    // Find the position of the first asterisk and delete the rest thereafter.
    for ( char* y = x; *y; y++ ) {
        if ( '*' == *y ) {
            if ( !asterisk ) {
                asterisk = y;
            }
            for ( char* z = y; *z; z++ )
                *z = *(z+1);
            y--;
        }
    }

    // Copy up to the first wildcard, then the numbers, then the rest of the filename.
    if ( asterisk ) {
        if ( (asterisk-x) > 0 )
            memcpy( p_filename, x, (asterisk - x) );

        sprintf( (p_filename+(asterisk-x)), "%05lu%09lu", pfx, gen_num );
        sprintf( (p_filename+strlen(p_filename)), "%s", asterisk );
    } else {
        memcpy( p_filename, x, strlen(x) );
    }

    // Open the handle to the output file.
    fp_out = fopen( p_filename, "wb" );
    if ( NULL == fp_out ) {
        fprintf( stderr, "Problem writing to output file at: '%s'\n", p_filename );
        free( (void*)p_filename );
        free( (void*)x );
        return;
    }

    // Attempt to write the output to the handle.
    size_t bytes_written = fwrite( p_data->output, sizeof(unsigned char),
        p_data->length, fp_out );

    if ( bytes_written != p_data->length )
        fprintf( stderr, "Problem writing all output to file at: '%s'\n", p_filename );

    fclose( fp_out );
    free( (void*)p_filename );
    free( (void*)x );

}
